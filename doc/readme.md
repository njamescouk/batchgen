% Batchgen
% Nick James
% 2016-06-05

<div class="article">
Introduction
============

batchgen is a program to generate dos batch files from a higher level
language, making it easier to use boolean logic in batch files.

One of the failings of DOS/command.com/cmd.exe is that the only logical
operator is "not". The other big failing is that it can't add up.
batchgen is an attempt to bring boolean logic to DOS. You need to be
quite happy writing batch files before using batchgen, it doesn't quite
write them for you. If you have experience of C life will be easier.

The big idea is that we use batchgen to do all the flow of control
transformations, whilst we enclose normal DOS commands [\# rem like this
\#]. batchgen turns the flow of control statements into legal DOS
commands, and copies text enclosed in [\#\#] verbatim. 
(this can lead to problems, see [Bugs](#bugs), below).

If we have the following as input:

<pre class = "programlisting">
    if (%1==%2 && ! %3==%4 || exist %5)
        [# rem this will be copied verbatim
           @echo it's true #]

</pre>

batchgen's output is:

<pre class = "programlisting">
    @echo off
    rem this file has been generated by batchgen and may be overwritten
    rem command line: batchgen  eg1.bg
    rem date 2016-5-5 18:32:59
    
    @goto main
    :main
    if "%1" == "%2" goto AT0
    goto ORF1
    :AT0
    if "%3" == "%4" goto ORF1
    goto IF0
    :ORF1
    if exist %5 goto IF0
    goto EI0
    :IF0
     rem this will be copied verbatim
           @echo it's true 
    rem endif
    :EI0
    :batch_end

</pre>

If you ask me, that's pretty slick, and it saves a lot of unecessary
thinking. 

batchgen is a run of the mill lex/yacc parser. The lexemes are
defined in [batchgen.l](../source/batchgen.l), the grammar and it's
associated semantic actions are defined in
[batchgen.y](../source/batchgen.y). The parser does not parse DOS
commands.

Usage
=====

    batchgen [filename] 

In the absence of a filename, batchgen
will read input from the command line, terminated with ctrl-z if you're
using the keyboard.

`batchgen filename` is equivalent to `batchgen < filename`
 is equivalent to `type filename | batchgen` and all three of these
command lines will work. 

`batchgen file1 file2` .. is equivalent to
`batchgen file1`. There are no warnings or errors.

Options
-------

The options are as follows:

-   -h prints a usage string

Output
------

Output is to `bg.bat` in the current directory.

Batchgen language
=================

The syntax is pretty much C like.

Version 3 handles functions by generating code that uses the call :label
syntax, see
[this](http://technet.microsoft.com/en-us/library/bb490873.aspx). There
are no changes in the grammar, but the generated code won't work unles
you're on XP or later.

break may only be used inside a while or switch statement. return;
returns control to the operating system. return primary\_expression; (eg
return 42;) is rewritten as exit /b primary\_expression, see
[this](http://technet.microsoft.com/en-us/library/bb490902.aspx). The
errorlevel when the batch file terminates is thus set to, for example,
42.

case and default are only legal inside a switch statement, despite the
grammar.

Blocks of dos code to be passed through are enclosed by [\# and \#].
This text is copied verbatim to the output batch file and should,
therefore, be legal DOS commands. batchgen does not parse this text.

Reserved words
--------------

if case else fdef switch default while return break || && == != \>= ""
errorlevel ERRORLEVEL exist EXIST

Batchgen grammar
----------------

<pre class = "programlisting">
<!--
 markupGrammar ..\source\batchgen.y
 Aug 10 2014 22:17:15
-->
<div class="YGrammar">
<div class="YTranslationRule">
<a name="batch_file"><b>batch_file:</b></a>
<div class="YProduction">
<span class="YAltProduction"><code><a href="#statement_list">statement_list</a> </code></span></div>
;<br/><br/></div>
<div class="YTranslationRule">
<a name="statement"><b>statement:</b></a>
<div class="YProduction">
<span class="YAltProduction"><code>dos_command </code></span><br />
| <span class="YAltProduction"><code><a href="#compound_statement">compound_statement</a> </code></span><br />
| <span class="YAltProduction"><code><a href="#selection_statement">selection_statement</a> </code></span><br />
| <span class="YAltProduction"><code><a href="#while_statement">while_statement</a> </code></span><br />
| <span class="YAltProduction"><code><a href="#labelled_statement">labelled_statement</a> </code></span><br />
| <span class="YAltProduction"><code><a href="#jump_statement">jump_statement</a> </code></span><br />
| <span class="YAltProduction"><code><a href="#function_definition">function_definition</a> </code></span><br />
| <span class="YAltProduction"><code><a href="#function_call">function_call</a> </code></span><br />
| <span class="YAltProduction"><code><a href="#error">error</a> </code></span></div>
;<br/><br/></div>
<div class="YTranslationRule">
<a name="function_definition"><b>function_definition:</b></a>
<div class="YProduction">
<span class="YAltProduction"><code>FDEF identifier '(' ')' <a href="#compound_statement">compound_statement</a> </code></span></div>
;<br/><br/></div>
<div class="YTranslationRule">
<a name="function_call"><b>function_call:</b></a>
<div class="YProduction">
<span class="YAltProduction"><code><a href="#function_identifier">function_identifier</a> '(' ')' </code></span></div>
;<br/><br/></div>
<div class="YTranslationRule">
<a name="labelled_statement"><b>labelled_statement:</b></a>
<div class="YProduction">
<span class="YAltProduction"><code>CASE <a href="#primary_expression">primary_expression</a> ':' <a href="#statement">statement</a> </code></span><br />
| <span class="YAltProduction"><code>DEFAULT ':' <a href="#statement">statement</a> </code></span></div>
;<br/><br/></div>
<div class="YTranslationRule">
<a name="compound_statement"><b>compound_statement:</b></a>
<div class="YProduction">
<span class="YAltProduction"><code>'{' <a href="#statement_list">statement_list</a> '}' </code></span><br />
| <span class="YAltProduction"><code>'{' '}' </code></span></div>
;<br/><br/></div>
<div class="YTranslationRule">
<a name="statement_list"><b>statement_list:</b></a>
<div class="YProduction">
<span class="YAltProduction"><code><a href="#statement">statement</a> </code></span><br />
| <span class="YAltProduction"><code><a href="#statement_list">statement_list</a> <a href="#statement">statement</a> </code></span></div>
;<br/><br/></div>
<div class="YTranslationRule">
<a name="selection_statement"><b>selection_statement:</b></a>
<div class="YProduction">
<span class="YAltProduction"><code>IF '(' <a href="#dos_expression">dos_expression</a> ')' <a href="#statement">statement</a> </code></span><br />
| <span class="YAltProduction"><code>IF '(' <a href="#dos_expression">dos_expression</a> ')' <a href="#statement">statement</a> ELSE <a href="#statement">statement</a> </code></span><br />
| <span class="YAltProduction"><code>SWITCH '(' <a href="#primary_expression">primary_expression</a> ')' <a href="#statement">statement</a> </code></span></div>
;<br/><br/></div>
<div class="YTranslationRule">
<a name="while_statement"><b>while_statement:</b></a>
<div class="YProduction">
<span class="YAltProduction"><code>WHILE '(' <a href="#dos_expression">dos_expression</a> ')' <a href="#statement">statement</a> </code></span></div>
;<br/><br/></div>
<div class="YTranslationRule">
<a name="jump_statement"><b>jump_statement:</b></a>
<div class="YProduction">
<span class="YAltProduction"><code>BREAK ';' </code></span><br />
| <span class="YAltProduction"><code>RETURN ';' </code></span><br />
| <span class="YAltProduction"><code>RETURN <a href="#primary_expression">primary_expression</a> ';' </code></span></div>
;<br/><br/></div>
<div class="YTranslationRule">
<a name="dos_expression"><b>dos_expression:</b></a>
<div class="YProduction">
<span class="YAltProduction"><code><a href="#logical_AND_expression">logical_AND_expression</a> </code></span><br />
| <span class="YAltProduction"><code><a href="#dos_expression">dos_expression</a> LOG_OR <a href="#logical_AND_expression">logical_AND_expression</a> </code></span></div>
;<br/><br/></div>
<div class="YTranslationRule">
<a name="logical_AND_expression"><b>logical_AND_expression:</b></a>
<div class="YProduction">
<span class="YAltProduction"><code><a href="#unary_expression">unary_expression</a> </code></span><br />
| <span class="YAltProduction"><code><a href="#logical_AND_expression">logical_AND_expression</a> LOG_AND <a href="#unary_expression">unary_expression</a> </code></span></div>
;<br/><br/></div>
<div class="YTranslationRule">
<a name="unary_expression"><b>unary_expression:</b></a>
<div class="YProduction">
<span class="YAltProduction"><code><a href="#dos_logical_expression">dos_logical_expression</a> </code></span><br />
| <span class="YAltProduction"><code>'(' <a href="#dos_expression">dos_expression</a> ')' </code></span><br />
| <span class="YAltProduction"><code>'!' <a href="#unary_expression">unary_expression</a> </code></span></div>
;<br/><br/></div>
<div class="YTranslationRule">
<a name="dos_logical_expression"><b>dos_logical_expression:</b></a>
<div class="YProduction">
<span class="YAltProduction"><code>ERRORLEVEL GE <a href="#primary_expression">primary_expression</a> </code></span><br />
| <span class="YAltProduction"><code>ERRORLEVEL '<' <a href="#primary_expression">primary_expression</a> </code></span><br />
| <span class="YAltProduction"><code>ERRORLEVEL EQ <a href="#primary_expression">primary_expression</a> </code></span><br />
| <span class="YAltProduction"><code>ERRORLEVEL NE <a href="#primary_expression">primary_expression</a> </code></span><br />
| <span class="YAltProduction"><code>EXIST <a href="#primary_expression">primary_expression</a> </code></span><br />
| <span class="YAltProduction"><code><a href="#primary_expression">primary_expression</a> EQ <a href="#primary_expression">primary_expression</a> </code></span><br />
| <span class="YAltProduction"><code><a href="#primary_expression">primary_expression</a> NE <a href="#primary_expression">primary_expression</a> </code></span></div>
;<br/><br/></div>
<div class="YTranslationRule">
<a name="primary_expression"><b>primary_expression:</b></a>
<div class="YProduction">
<span class="YAltProduction"><code>identifier </code></span><br />
| <span class="YAltProduction"><code><a href="#primary_expression">primary_expression</a> identifier </code></span><br />
| <span class="YAltProduction"><code>en_var </code></span><br />
| <span class="YAltProduction"><code><a href="#primary_expression">primary_expression</a> en_var </code></span><br />
| <span class="YAltProduction"><code>param </code></span><br />
| <span class="YAltProduction"><code><a href="#primary_expression">primary_expression</a> param </code></span><br />
| <span class="YAltProduction"><code>number </code></span><br />
| <span class="YAltProduction"><code><a href="#primary_expression">primary_expression</a> number </code></span><br />
| <span class="YAltProduction"><code>empty </code></span></div>
;<br/><br/></div>
<div class="YTranslationRule">
<a name="function_identifier"><b>function_identifier:</b></a>
<div class="YProduction">
<span class="YAltProduction"><code>func_id </code></span></div>
;<br/><br/></div>
</div>

</pre>

The non terminals identifier, en\_var and param are defined as follows:

-   identifier
    ({letter}|{digit}|\\\\|\\.|\\-)([a-zA-Z\$\\.\\\\\_\\\*:]|{digit})\*
    - this should boil down to a dos directory name

-   en\_var - is an identifier surrounded by %%

-   param - is a parameter prefixed by %

Building
========

You need:

-   a C++ compiler

-   lex and yacc binaries

compile.bat (in bin) will compile from the command line. Using MinGW
produces a buggy program, you're better off using Visual Studio Express
2010 (free) and the batchgen.sln file (in vce2010).

The VC project doesn't run lex and yacc: bin\\doLexYacc.bat calls lex
and yacc (I use the [GnuWin32](http://gnuwin32.sourceforge.net/) ones).
Running yacc on batchgen.y gives the following error:

     state contains 1 shift/reduce conflict.

This is the if-else ambiguity, we accept yacc's default resolution.

There are some test files in tests, these should all generate and
optimize without error.

Bugs
====

-   The contents of input and output files are held in main memory,
    consequently you could run out of memory.

-   Trailing space on environmental variables. This can be a real pain.

        [# set VAR=99 #]

    when translated and executed by the OS will give VAR the value "99
    ". You will be saying something like

        if "VAR"=="99" do something

    and your program won't do something, it will do nothing. This is
    because VAR has the value "99 ", not "99".

-   It's not written in C++. Some of the code is pretty nasty in
    retrospect (2011) but it more or less works.

-   function parameters not supported. This doesn't stop you defining a
    function that uses parameters, but you will have to call it using
    something like [\# call func arg1 arg2 \#] rather than func(arg2,
    arg2).

-   UTF-8 files with a byte order mark cause batchgen to fail with the
    helpful 'syntax error on line 1' message. UTF-8 files that are
    ANSI-in-disguise are ok; I suspect multibyte characters will make
    batchgen fall over.

See also
========

[quick reference](quickref.txt)

[gotchas](gotchas.txt)

[grammar diagram](batchgen.y.dot.jpeg)

Acknowledgments
===============

This program is pretty much lifted from Compilers: Principles,
Techniques and Tools by Aho, Sethi and Ullman, pub Addison Wesley 1986.

The grammar is pretty much lifted from C.

Colophon
========

Produced with

    pp readme.md.pp > readme.md

</div>