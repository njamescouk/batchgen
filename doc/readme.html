<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="author" content="Nick James">
  <meta name="dcterms.date" content="2016-06-05">
  <title>batchgen - Batchgen</title>
  <!--[if lt IE 9]>
    <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <link rel="stylesheet" href="main.css">
</head>
<body>
<header>
<h1 class="title">Batchgen</h1>
<h2 class="author">Nick James</h2>
<h3 class="date">2016-06-05</h3>
</header>
<nav id="TOC">
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#usage">Usage</a><ul>
<li><a href="#options">Options</a></li>
<li><a href="#output">Output</a></li>
</ul></li>
<li><a href="#batchgen-language">Batchgen language</a><ul>
<li><a href="#reserved-words">Reserved words</a></li>
<li><a href="#batchgen-grammar">Batchgen grammar</a></li>
</ul></li>
<li><a href="#building">Building</a></li>
<li><a href="#bugs">Bugs</a></li>
<li><a href="#see-also">See also</a></li>
<li><a href="#acknowledgments">Acknowledgments</a></li>
<li><a href="#colophon">Colophon</a></li>
</ul>
</nav>
<div class="article">
<h1 id="introduction"><a href="#TOC">Introduction</a></h1>
<p>batchgen is a program to generate dos batch files from a higher level language, making it easier to use boolean logic in batch files.</p>
<p>One of the failings of DOS/command.com/cmd.exe is that the only logical operator is &quot;not&quot;. The other big failing is that it can't add up. batchgen is an attempt to bring boolean logic to DOS. You need to be quite happy writing batch files before using batchgen, it doesn't quite write them for you. If you have experience of C life will be easier.</p>
<p>The big idea is that we use batchgen to do all the flow of control transformations, whilst we enclose normal DOS commands [# rem like this #]. batchgen turns the flow of control statements into legal DOS commands, and copies text enclosed in [##] verbatim. (this can lead to problems, see <a href="#bugs">Bugs</a>, below).</p>
<p>If we have the following as input:</p>
<pre class = "programlisting">
    if (%1==%2 && ! %3==%4 || exist %5)
        [# rem this will be copied verbatim
           @echo it's true #]

</pre>

<p>batchgen's output is:</p>
<pre class = "programlisting">
    @echo off
    rem this file has been generated by batchgen and may be overwritten
    rem command line: batchgen  eg1.bg
    rem date 2016-5-5 18:32:59

    @goto main
    :main
    if "%1" == "%2" goto AT0
    goto ORF1
    :AT0
    if "%3" == "%4" goto ORF1
    goto IF0
    :ORF1
    if exist %5 goto IF0
    goto EI0
    :IF0
     rem this will be copied verbatim
           @echo it's true 
    rem endif
    :EI0
    :batch_end

</pre>

<p>If you ask me, that's pretty slick, and it saves a lot of unecessary thinking.</p>
<p>batchgen is a run of the mill lex/yacc parser. The lexemes are defined in <a href="../source/batchgen.l">batchgen.l</a>, the grammar and it's associated semantic actions are defined in <a href="../source/batchgen.y">batchgen.y</a>. The parser does not parse DOS commands.</p>
<h1 id="usage"><a href="#TOC">Usage</a></h1>
<pre><code>batchgen [filename] </code></pre>
<p>In the absence of a filename, batchgen will read input from the command line, terminated with ctrl-z if you're using the keyboard.</p>
<p><code>batchgen filename</code> is equivalent to <code>batchgen &lt; filename</code> is equivalent to <code>type filename | batchgen</code> and all three of these command lines will work.</p>
<p><code>batchgen file1 file2</code> .. is equivalent to <code>batchgen file1</code>. There are no warnings or errors.</p>
<h2 id="options"><a href="#TOC">Options</a></h2>
<p>The options are as follows:</p>
<ul>
<li>-h prints a usage string</li>
</ul>
<h2 id="output"><a href="#TOC">Output</a></h2>
<p>Output is to <code>bg.bat</code> in the current directory.</p>
<h1 id="batchgen-language"><a href="#TOC">Batchgen language</a></h1>
<p>The syntax is pretty much C like.</p>
<p>Version 3 handles functions by generating code that uses the call :label syntax, see <a href="http://technet.microsoft.com/en-us/library/bb490873.aspx">this</a>. There are no changes in the grammar, but the generated code won't work unles you're on XP or later.</p>
<p>break may only be used inside a while or switch statement. return; returns control to the operating system. return primary_expression; (eg return 42;) is rewritten as exit /b primary_expression, see <a href="http://technet.microsoft.com/en-us/library/bb490902.aspx">this</a>. The errorlevel when the batch file terminates is thus set to, for example, 42.</p>
<p>case and default are only legal inside a switch statement, despite the grammar.</p>
<p>Blocks of dos code to be passed through are enclosed by [# and #]. This text is copied verbatim to the output batch file and should, therefore, be legal DOS commands. batchgen does not parse this text.</p>
<h2 id="reserved-words"><a href="#TOC">Reserved words</a></h2>
<p>if case else fdef switch default while return break || &amp;&amp; == != &gt;= &quot;&quot; errorlevel ERRORLEVEL exist EXIST</p>
<h2 id="batchgen-grammar"><a href="#TOC">Batchgen grammar</a></h2>
<pre class = "programlisting">
<!--
 markupGrammar ..\source\batchgen.y
 Aug 10 2014 22:17:15
-->
<div class="YGrammar">
<div class="YTranslationRule">
<a name="batch_file"><b>batch_file:</b></a>
<div class="YProduction">
<span class="YAltProduction"><code><a href="#statement_list">statement_list</a> </code></span></div>
;<br/><br/></div>
<div class="YTranslationRule">
<a name="statement"><b>statement:</b></a>
<div class="YProduction">
<span class="YAltProduction"><code>dos_command </code></span><br />
| <span class="YAltProduction"><code><a href="#compound_statement">compound_statement</a> </code></span><br />
| <span class="YAltProduction"><code><a href="#selection_statement">selection_statement</a> </code></span><br />
| <span class="YAltProduction"><code><a href="#while_statement">while_statement</a> </code></span><br />
| <span class="YAltProduction"><code><a href="#labelled_statement">labelled_statement</a> </code></span><br />
| <span class="YAltProduction"><code><a href="#jump_statement">jump_statement</a> </code></span><br />
| <span class="YAltProduction"><code><a href="#function_definition">function_definition</a> </code></span><br />
| <span class="YAltProduction"><code><a href="#function_call">function_call</a> </code></span><br />
| <span class="YAltProduction"><code><a href="#error">error</a> </code></span></div>
;<br/><br/></div>
<div class="YTranslationRule">
<a name="function_definition"><b>function_definition:</b></a>
<div class="YProduction">
<span class="YAltProduction"><code>FDEF identifier '(' ')' <a href="#compound_statement">compound_statement</a> </code></span></div>
;<br/><br/></div>
<div class="YTranslationRule">
<a name="function_call"><b>function_call:</b></a>
<div class="YProduction">
<span class="YAltProduction"><code><a href="#function_identifier">function_identifier</a> '(' ')' </code></span></div>
;<br/><br/></div>
<div class="YTranslationRule">
<a name="labelled_statement"><b>labelled_statement:</b></a>
<div class="YProduction">
<span class="YAltProduction"><code>CASE <a href="#primary_expression">primary_expression</a> ':' <a href="#statement">statement</a> </code></span><br />
| <span class="YAltProduction"><code>DEFAULT ':' <a href="#statement">statement</a> </code></span></div>
;<br/><br/></div>
<div class="YTranslationRule">
<a name="compound_statement"><b>compound_statement:</b></a>
<div class="YProduction">
<span class="YAltProduction"><code>'{' <a href="#statement_list">statement_list</a> '}' </code></span><br />
| <span class="YAltProduction"><code>'{' '}' </code></span></div>
;<br/><br/></div>
<div class="YTranslationRule">
<a name="statement_list"><b>statement_list:</b></a>
<div class="YProduction">
<span class="YAltProduction"><code><a href="#statement">statement</a> </code></span><br />
| <span class="YAltProduction"><code><a href="#statement_list">statement_list</a> <a href="#statement">statement</a> </code></span></div>
;<br/><br/></div>
<div class="YTranslationRule">
<a name="selection_statement"><b>selection_statement:</b></a>
<div class="YProduction">
<span class="YAltProduction"><code>IF '(' <a href="#dos_expression">dos_expression</a> ')' <a href="#statement">statement</a> </code></span><br />
| <span class="YAltProduction"><code>IF '(' <a href="#dos_expression">dos_expression</a> ')' <a href="#statement">statement</a> ELSE <a href="#statement">statement</a> </code></span><br />
| <span class="YAltProduction"><code>SWITCH '(' <a href="#primary_expression">primary_expression</a> ')' <a href="#statement">statement</a> </code></span></div>
;<br/><br/></div>
<div class="YTranslationRule">
<a name="while_statement"><b>while_statement:</b></a>
<div class="YProduction">
<span class="YAltProduction"><code>WHILE '(' <a href="#dos_expression">dos_expression</a> ')' <a href="#statement">statement</a> </code></span></div>
;<br/><br/></div>
<div class="YTranslationRule">
<a name="jump_statement"><b>jump_statement:</b></a>
<div class="YProduction">
<span class="YAltProduction"><code>BREAK ';' </code></span><br />
| <span class="YAltProduction"><code>RETURN ';' </code></span><br />
| <span class="YAltProduction"><code>RETURN <a href="#primary_expression">primary_expression</a> ';' </code></span></div>
;<br/><br/></div>
<div class="YTranslationRule">
<a name="dos_expression"><b>dos_expression:</b></a>
<div class="YProduction">
<span class="YAltProduction"><code><a href="#logical_AND_expression">logical_AND_expression</a> </code></span><br />
| <span class="YAltProduction"><code><a href="#dos_expression">dos_expression</a> LOG_OR <a href="#logical_AND_expression">logical_AND_expression</a> </code></span></div>
;<br/><br/></div>
<div class="YTranslationRule">
<a name="logical_AND_expression"><b>logical_AND_expression:</b></a>
<div class="YProduction">
<span class="YAltProduction"><code><a href="#unary_expression">unary_expression</a> </code></span><br />
| <span class="YAltProduction"><code><a href="#logical_AND_expression">logical_AND_expression</a> LOG_AND <a href="#unary_expression">unary_expression</a> </code></span></div>
;<br/><br/></div>
<div class="YTranslationRule">
<a name="unary_expression"><b>unary_expression:</b></a>
<div class="YProduction">
<span class="YAltProduction"><code><a href="#dos_logical_expression">dos_logical_expression</a> </code></span><br />
| <span class="YAltProduction"><code>'(' <a href="#dos_expression">dos_expression</a> ')' </code></span><br />
| <span class="YAltProduction"><code>'!' <a href="#unary_expression">unary_expression</a> </code></span></div>
;<br/><br/></div>
<div class="YTranslationRule">
<a name="dos_logical_expression"><b>dos_logical_expression:</b></a>
<div class="YProduction">
<span class="YAltProduction"><code>ERRORLEVEL GE <a href="#primary_expression">primary_expression</a> </code></span><br />
| <span class="YAltProduction"><code>ERRORLEVEL '<' <a href="#primary_expression">primary_expression</a> </code></span><br />
| <span class="YAltProduction"><code>ERRORLEVEL EQ <a href="#primary_expression">primary_expression</a> </code></span><br />
| <span class="YAltProduction"><code>ERRORLEVEL NE <a href="#primary_expression">primary_expression</a> </code></span><br />
| <span class="YAltProduction"><code>EXIST <a href="#primary_expression">primary_expression</a> </code></span><br />
| <span class="YAltProduction"><code><a href="#primary_expression">primary_expression</a> EQ <a href="#primary_expression">primary_expression</a> </code></span><br />
| <span class="YAltProduction"><code><a href="#primary_expression">primary_expression</a> NE <a href="#primary_expression">primary_expression</a> </code></span></div>
;<br/><br/></div>
<div class="YTranslationRule">
<a name="primary_expression"><b>primary_expression:</b></a>
<div class="YProduction">
<span class="YAltProduction"><code>identifier </code></span><br />
| <span class="YAltProduction"><code><a href="#primary_expression">primary_expression</a> identifier </code></span><br />
| <span class="YAltProduction"><code>en_var </code></span><br />
| <span class="YAltProduction"><code><a href="#primary_expression">primary_expression</a> en_var </code></span><br />
| <span class="YAltProduction"><code>param </code></span><br />
| <span class="YAltProduction"><code><a href="#primary_expression">primary_expression</a> param </code></span><br />
| <span class="YAltProduction"><code>number </code></span><br />
| <span class="YAltProduction"><code><a href="#primary_expression">primary_expression</a> number </code></span><br />
| <span class="YAltProduction"><code>empty </code></span></div>
;<br/><br/></div>
<div class="YTranslationRule">
<a name="function_identifier"><b>function_identifier:</b></a>
<div class="YProduction">
<span class="YAltProduction"><code>func_id </code></span></div>
;<br/><br/></div>
</div>

</pre>

<p>The non terminals identifier, en_var and param are defined as follows:</p>
<ul>
<li>identifier ({letter}|{digit}|\\|\.|\-)([a-zA-Z$\.\\_\*:]|{digit})*
<ul>
<li>this should boil down to a dos directory name</li>
</ul></li>
<li><p>en_var - is an identifier surrounded by %%</p></li>
<li><p>param - is a parameter prefixed by %</p></li>
</ul>
<h1 id="building"><a href="#TOC">Building</a></h1>
<p>You need:</p>
<ul>
<li><p>a C++ compiler</p></li>
<li><p>lex and yacc binaries</p></li>
</ul>
<p>compile.bat (in bin) will compile from the command line. Using MinGW produces a buggy program, you're better off using Visual Studio Express 2010 (free) and the batchgen.sln file (in vce2010).</p>
<p>The VC project doesn't run lex and yacc: bin\doLexYacc.bat calls lex and yacc (I use the <a href="http://gnuwin32.sourceforge.net/">GnuWin32</a> ones). Running yacc on batchgen.y gives the following error:</p>
<pre><code> state contains 1 shift/reduce conflict.</code></pre>
<p>This is the if-else ambiguity, we accept yacc's default resolution.</p>
<p>There are some test files in tests, these should all generate and optimize without error.</p>
<h1 id="bugs"><a href="#TOC">Bugs</a></h1>
<ul>
<li><p>The contents of input and output files are held in main memory, consequently you could run out of memory.</p></li>
<li><p>Trailing space on environmental variables. This can be a real pain.</p>
<pre><code>[# set VAR=99 #]</code></pre>
<p>when translated and executed by the OS will give VAR the value &quot;99 &quot;. You will be saying something like</p>
<pre><code>if &quot;VAR&quot;==&quot;99&quot; do something</code></pre>
<p>and your program won't do something, it will do nothing. This is because VAR has the value &quot;99 &quot;, not &quot;99&quot;.</p></li>
<li><p>It's not written in C++. Some of the code is pretty nasty in retrospect (2011) but it more or less works.</p></li>
<li><p>function parameters not supported. This doesn't stop you defining a function that uses parameters, but you will have to call it using something like [# call func arg1 arg2 #] rather than func(arg2, arg2).</p></li>
<li><p>UTF-8 files with a byte order mark cause batchgen to fail with the helpful 'syntax error on line 1' message. UTF-8 files that are ANSI-in-disguise are ok; I suspect multibyte characters will make batchgen fall over.</p></li>
</ul>
<h1 id="see-also"><a href="#TOC">See also</a></h1>
<p><a href="quickref.txt">quick reference</a></p>
<p><a href="gotchas.txt">gotchas</a></p>
<p><a href="batchgen.y.dot.jpeg">grammar diagram</a></p>
<h1 id="acknowledgments"><a href="#TOC">Acknowledgments</a></h1>
<p>This program is pretty much lifted from Compilers: Principles, Techniques and Tools by Aho, Sethi and Ullman, pub Addison Wesley 1986.</p>
<p>The grammar is pretty much lifted from C.</p>
<h1 id="colophon"><a href="#TOC">Colophon</a></h1>
<p>Produced with</p>
<pre><code>pp readme.md.pp &gt; readme.md</code></pre>
</div>
</body>
</html>
