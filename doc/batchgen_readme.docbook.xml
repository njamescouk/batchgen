<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
"http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd">
<article>
  <title>Batchgen - a batch file generator</title>

  <articleinfo>
    <revhistory>
      <revision>
        <revnumber>1</revnumber>

        <date>30-7-2007</date>
      </revision>

      <revision>
        <revnumber>2</revnumber>

        <date>31-10-2008</date>

        <revdescription>
          <para>Having noticed that this program has been consistently
          downloaded over the last 4 years, and in the belief that someone may
          actually be using it, I've tweaked the documentation. In addition
          the improvements to the (previously arcane) file upload process on
          <ulink
          url="https://sourceforge.net/projects/batchgen/">sourceforge</ulink>
          make it possible to upload the version 1.2 zip, as well as hosting
          it on <ulink url="http://www.njames.co.uk/desktop.html">my own
          site</ulink>.</para>
        </revdescription>
      </revision>
    </revhistory>

    <date>31-10-2008</date>

    <author>
      <firstname>Nick</firstname>

      <surname>James</surname>
    </author>
  </articleinfo>

  <warning>
    <para>This software contains known and unknown bugs: use it at your own
    risk.</para>
  </warning>

  <abstract>
    <para>batchgen is a program to generate dos batch files from a higher
    level language, making it easier to use boolean logic in batch
    files.</para>
  </abstract>

  <sect1>
    <title>Introduction</title>

    <para>One of the failings of DOS/command.com/cmd.exe is that the only
    logical operator is "not". The other big failing is that it can't add up.
    batchgen is an attempt to bring boolean logic to DOS. You need to be quite
    happy writing batch files before using batchgen, it doesn't quite write
    them for you. If you have experience of C life will be easier.</para>

    <para>The big idea is that we use batchgen to do all the flow of control
    transformations, whilst we enclose normal DOS commands [# rem like this
    #]. batchgen turns the flow of control statements into legal DOS commands,
    and copies text enclosed in [##] verbatim. (this can lead to problems, see
    <link linkend="bugs">Bugs</link>, below).</para>

    <para>If we have the following as input:<programlisting>if (%1==%2 &amp;&amp; ! %3==%4 || exist %5)
    [# rem this will be copied verbatim
       @echo it's true #]</programlisting> batchgen's output
    is:<programlisting>@goto main
:main
if "%1" == "%2" goto AT0
goto ORF1
:AT0
if "%3" == "%4" goto ORF1
goto IF0
:ORF1
if exist %5 goto IF0
goto EI0
:IF0

     rem this will be copied verbatim
     @echo it's true
   
rem endif
:EI0
:batch_end</programlisting> if we ask for optimization we get:<programlisting>if not "%1" == "%2" goto ORF1
if not "%3" == "%4" goto IF0
:ORF1
if not exist %5 goto EI0
:IF0
     @echo it's true
:EI0</programlisting> If you ask me, that's pretty slick, and it saves a lot
    of unecessary thinking. batchgen is a run of the mill lex/yacc parser. The
    lexemes are defined in <ulink
    url="../source/batchgen.l">batchgen.l</ulink>, the grammar and it's
    associated semantic actions are defined in <ulink
    url="../source/batchgen.y">batchgen.y</ulink>. The parser does not parse
    DOS commands.</para>
  </sect1>

  <sect1>
    <title>Usage</title>

    <para><synopsis>batchgen [-o[r|b]] [filename]</synopsis> In the absence of
    a filename, batchgen will read input from the command line, terminated
    with ctrl-z if you're using the keyboard.<synopsis>batchgen filename</synopsis>
    is equivalent to<synopsis>batchgen &lt; filename</synopsis> is equivalent
    to<synopsis>type filename | batchgen</synopsis> and all three of these
    command lines will work. batchgen file1 file2 .. is equivalent to batchgen
    file1. There are no warnings or errors.</para>

    <sect2>
      <title>Options</title>

      <para>The options are as follows:<itemizedlist>
          <listitem>
            <para>-o optimizes but leaves lines beginning with rem and blank
            lines</para>
          </listitem>

          <listitem>
            <para>-or optimizes as for -o and also removes rems</para>
          </listitem>

          <listitem>
            <para>-ob optimizes as for -o and also removes blank lines</para>
          </listitem>

          <listitem>
            <para>-orb = -obr is full on optimization</para>
          </listitem>

          <listitem>
            <para>-h prints a usage string</para>
          </listitem>
        </itemizedlist></para>
    </sect2>

    <sect2>
      <title>Output</title>

      <para>Output is to bg.bat in the current directory. If you've asked for
      optimization, your output is in bg.bat and the optimized output is in
      bgo.bat. If optimization fails (see Bugs, below) bgo.bat is written,
      with code that makes it return immediately wrapped round it, so as not
      to execute potentially damaging instructions..</para>
    </sect2>
  </sect1>

  <sect1>
    <title>Batchgen language</title>

    <para>The syntax is pretty much C like.</para>

    <para>Functions do not take parameters, nor do they return values. It is
    an error for a function definition to contain a function call, ie
    functions cannot be nested, owing to the extremely crude return mechanism.
    Functions must have been defined before they can be called.</para>

    <para>break may only be used inside a while or switch statement. return;
    may be used in a function, in which case control goes back to the main
    program, or in the main program, in which case control returns to the
    operating system. return primary_expression; (eg return 42;) is a bit of a
    bodge; a program called el is invoked, which returns it's argument as an
    int. Control is then given to the operating system. The errorlevel when
    the batch file terminates is thus set to, for example, 42. This requires
    that the program el.com or el.exe be available to your batch file.</para>

    <para>case and default are only legal inside a switch statement, despite
    the grammar.</para>

    <para>Blocks of dos code to be passed through are enclosed by [# and #].
    This text is copied verbatim to the output batch file. This should,
    therefore, be legal DOS commands. batchgen does not parse this
    text.</para>

    <sect2>
      <title>Reserved words</title>

      <para>if case else switch default while return break fdef || &amp;&amp;
      == != &gt;= "" errorlevel ERRORLEVEL exist EXIST</para>
    </sect2>

    <sect2>
      <title>Grammar</title>

      <programlisting><anchor id="batch_file" /><emphasis>batch_file:</emphasis>
<link linkend="statement_list">statement_list</link> 
;

<anchor id="statement" /><emphasis>statement:</emphasis>
  dos_command 
| <link linkend="compound_statement">compound_statement</link> 
| <link linkend="selection_statement">selection_statement</link> 
| <link linkend="while_statement">while_statement</link> 
| <link linkend="labelled_statement">labelled_statement</link> 
| <link linkend="jump_statement">jump_statement</link> 
| <link linkend="function_definition">function_definition</link> 
| <link linkend="function_call">function_call</link> 
| 
;

<anchor id="function_definition" /><emphasis>function_definition:</emphasis>
FDEF identifier '(' ')' <link linkend="compound_statement">compound_statement</link> 
;

<anchor id="function_call" /><emphasis>function_call:</emphasis>
<link linkend="function_identifier">function_identifier</link> '(' ')' 
;

<anchor id="labelled_statement" /><emphasis>labelled_statement:</emphasis>
  CASE <link linkend="primary_expression">primary_expression</link> ':' <link
          linkend="statement">statement</link> 
| DEFAULT ':' <link linkend="statement">statement</link> 
;

<anchor id="compound_statement" /><emphasis>compound_statement:</emphasis>
  '{' <link linkend="statement_list">statement_list</link> '}' 
| '{' '}' 
;

<anchor id="statement_list" /><emphasis>statement_list:</emphasis>
  <link linkend="statement">statement</link> 
| <link linkend="statement_list">statement_list</link> <link
          linkend="statement">statement</link> 
;

<anchor id="selection_statement" /><emphasis>selection_statement:</emphasis>
  IF '(' <link linkend="dos_expression">dos_expression</link> ')' <link
          linkend="statement">statement</link> 
| IF '(' <link linkend="dos_expression">dos_expression</link> ')' <link
          linkend="statement">statement</link> ELSE <link linkend="statement">statement</link> 
| SWITCH '(' <link linkend="primary_expression">primary_expression</link> ')' <link
          linkend="statement">statement</link> 
;

<anchor id="while_statement" /><emphasis>while_statement:</emphasis>
WHILE '(' <link linkend="dos_expression">dos_expression</link> ')' <link
          linkend="statement">statement</link> 
;

<anchor id="jump_statement" /><emphasis>jump_statement:</emphasis>
  BREAK ';' 
| RETURN ';' 
| RETURN <link linkend="primary_expression">primary_expression</link> ';' 
;

<anchor id="dos_expression" /><emphasis>dos_expression:</emphasis>
  <link linkend="logical_AND_expression">logical_AND_expression</link> 
| <link linkend="dos_expression">dos_expression</link> LOG_OR <link
          linkend="logical_AND_expression">logical_AND_expression</link> 
;

<anchor id="logical_AND_expression" /><emphasis>logical_AND_expression:</emphasis>
  <link linkend="unary_expression">unary_expression</link> 
| <link linkend="logical_AND_expression">logical_AND_expression</link> LOG_AND <link
          linkend="unary_expression">unary_expression</link> 
;

<anchor id="unary_expression" /><emphasis>unary_expression:</emphasis>
  <link linkend="dos_logical_expression">dos_logical_expression</link> 
| '(' <link linkend="dos_expression">dos_expression</link> ')' 
| '!' <link linkend="unary_expression">unary_expression</link> 
;

<anchor id="dos_logical_expression" /><emphasis>dos_logical_expression:</emphasis>
  ERRORLEVEL GE <link linkend="primary_expression">primary_expression</link> 
| ERRORLEVEL &lt; <link linkend="primary_expression">primary_expression</link> 
| ERRORLEVEL EQ <link linkend="primary_expression">primary_expression</link> 
| ERRORLEVEL NE <link linkend="primary_expression">primary_expression</link> 
| EXIST <link linkend="primary_expression">primary_expression</link> 
| <link linkend="primary_expression">primary_expression</link> EQ <link
          linkend="primary_expression">primary_expression</link> 
| <link linkend="primary_expression">primary_expression</link> NE <link
          linkend="primary_expression">primary_expression</link> 
;

<anchor id="primary_expression" /><emphasis>primary_expression:</emphasis>
  identifier 
| <link linkend="primary_expression">primary_expression</link> identifier 
| en_var 
| <link linkend="primary_expression">primary_expression</link> en_var 
| param 
| <link linkend="primary_expression">primary_expression</link> param 
| number 
| <link linkend="primary_expression">primary_expression</link> number 
| empty 
;

<anchor id="function_identifier" /><emphasis>function_identifier:</emphasis>
func_id 
;

</programlisting>

      <para>The non terminals identifier, func_id, en_var and param are
      defined as follows:<itemizedlist>
          <listitem>
            <para>identifier
            ({letter}|{digit}|\\|\.|\-)([a-zA-Z$\.\\_\*:]|{digit})* - this
            should boil down to a dos directory name</para>
          </listitem>

          <listitem>
            <para>func_id - is an identifer that has been fdef'd</para>
          </listitem>

          <listitem>
            <para>en_var - is an identifier surrounded by %%</para>
          </listitem>

          <listitem>
            <para>param - is a parameter prefixed by %</para>
          </listitem>
        </itemizedlist></para>
    </sect2>
  </sect1>

  <sect1>
    <title>Building</title>

    <para>There is a generated guide to the source <ulink
    url="doxy/index.html">here</ulink>.</para>

    <para>You need:<itemizedlist>
        <listitem>
          <para>a C++ compiler</para>
        </listitem>

        <listitem>
          <para>lex and yacc binaries</para>
        </listitem>
      </itemizedlist>vc_make.bat (derived from vc_make.bc) will build the
    source using VC++. If you have another compiler, the <programlisting>    set CC=cl</programlisting>and<programlisting>    set CC_FLAGS= ...</programlisting>lines
    should be changed. There are VC++ project and workspace files should they
    be any use to you which will need copying to the source directory.</para>

    <para>running yacc on batchgen.y gives the following
    error:<programlisting> state contains 1 shift/reduce conflict.</programlisting>This
    is the if-else ambiguity, we accept yacc's default resolution.</para>
  </sect1>

  <sect1>
    <title><anchor id="bugs" />Bugs</title>

    <para><itemizedlist>
        <listitem>
          <para>The optimizer cannot do agressive optimization without
          removing comments and blank lines.</para>
        </listitem>

        <listitem>
          <para>The contents of input and output files are held in main
          memory, consequently you could run out of memory.</para>
        </listitem>

        <listitem>
          <para>Trailing space on environmental variables. This can be a real
          pain. <programlisting>[# set VAR=99 #]</programlisting> when
          translated and executed by the OS will give VAR the value "99 ". You
          will be saying something like <programlisting>if "VAR"=="99" do something</programlisting>
          and your program won't do something, it will do nothing. This is
          because VAR has the value "99 ", not "99".</para>
        </listitem>
      </itemizedlist></para>
  </sect1>

  <sect1>
    <title>Acknowledgments</title>

    <para>This program is pretty much lifted from Compilers: Principles,
    Techniques and Tools by Aho, Sethi and Ullman, pub Addison Wesley
    1986.</para>

    <para>The grammar is pretty much lifted from C.</para>
  </sect1>
</article>